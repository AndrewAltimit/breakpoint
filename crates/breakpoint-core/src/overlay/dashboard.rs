use serde::{Deserialize, Serialize};

use crate::events::Event;

/// Agent session status shown in the dashboard.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum AgentStatus {
    Working,
    Waiting,
    Blocked,
    Idle,
}

/// Aggregate statistics for the dashboard view.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DashboardStats {
    pub events_last_hour: u32,
    pub events_last_minute: u32,
    pub agents_active: u32,
    pub agents_blocked: u32,
}

/// Filter mode for the dashboard event list.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Serialize, Deserialize)]
pub enum DashboardFilter {
    #[default]
    All,
    AgentOnly,
    HumanOnly,
}

/// Check if an event matches the given dashboard filter.
pub fn matches_filter(event: &Event, filter: DashboardFilter) -> bool {
    match filter {
        DashboardFilter::All => true,
        DashboardFilter::AgentOnly => is_agent_event(event),
        DashboardFilter::HumanOnly => !is_agent_event(event),
    }
}

/// Check if an event was generated by an agent (via metadata).
pub fn is_agent_event(event: &Event) -> bool {
    event
        .metadata
        .get("is_agent")
        .is_some_and(|v| v.as_bool() == Some(true))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::events::{EventType, Priority};
    use std::collections::HashMap;

    fn make_event(is_agent: bool) -> Event {
        let mut metadata = HashMap::new();
        if is_agent {
            metadata.insert("is_agent".to_string(), serde_json::Value::Bool(true));
        }
        Event {
            id: "evt-1".to_string(),
            event_type: EventType::PrOpened,
            source: "test".to_string(),
            priority: Priority::Notice,
            title: "Test event".to_string(),
            body: None,
            timestamp: "2026-01-01T00:00:00Z".to_string(),
            url: None,
            actor: Some("test-actor".to_string()),
            tags: vec![],
            action_required: false,
            group_key: None,
            expires_at: None,
            metadata,
        }
    }

    #[test]
    fn is_agent_event_true() {
        let event = make_event(true);
        assert!(is_agent_event(&event));
    }

    #[test]
    fn is_agent_event_false() {
        let event = make_event(false);
        assert!(!is_agent_event(&event));
    }

    #[test]
    fn filter_all() {
        assert!(matches_filter(&make_event(true), DashboardFilter::All));
        assert!(matches_filter(&make_event(false), DashboardFilter::All));
    }

    #[test]
    fn filter_agent_only() {
        assert!(matches_filter(
            &make_event(true),
            DashboardFilter::AgentOnly
        ));
        assert!(!matches_filter(
            &make_event(false),
            DashboardFilter::AgentOnly
        ));
    }

    #[test]
    fn filter_human_only() {
        assert!(!matches_filter(
            &make_event(true),
            DashboardFilter::HumanOnly
        ));
        assert!(matches_filter(
            &make_event(false),
            DashboardFilter::HumanOnly
        ));
    }
}
